/**
 * Kinde Management API
 * Provides endpoints to manage your Kinde Businesses
 *
 * The version of the OpenAPI document: 1
 * Contact: support@kinde.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
import sinon from 'sinon';

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD.
    define(['expect.js', process.cwd()+'/src/index'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    factory(require('expect.js'), require(process.cwd()+'/src/index'));
  } else {
    // Browser globals (root is window)
    factory(root.expect, root.KindeManagementApi);
  }
}(this, function(expect, KindeManagementApi) {
  'use strict';

  var instance;
  const options = {
    domain: "https://example.com",
    clientId: "test_client_id",
    clientSecret: "test_client_secret",
    redirectUri: "test_redirect_uri",
    logoutRedirectUri: "https://example.com/logout",
    grantType: 'authorization_code',
  };

  beforeEach(function() {
    instance = new KindeManagementApi.KindeClient(options);
  });

  describe('KindeClient', function() {
    describe('constructor', function() {
      it('should create an instance of KindeClient', function() {
        expect(instance.domain).to.equal(options.domain);
        expect(instance.clientId).to.equal(options.clientId);
        expect(instance.clientSecret).to.equal(options.clientSecret);
        expect(instance.redirectUri).to.equal(options.redirectUri);
        expect(instance.logoutRedirectUri).to.equal(options.logoutRedirectUri);
        expect(instance.grantType).to.equal(options.grantType);
      });
    });

    describe('login', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call login successfully', async () => {
        const kindeClient = new KindeManagementApi.KindeClient({
          domain: 'https://example.com',
          clientId: 'client_id',
          clientSecret: 'client_secret',
          redirectUri: 'https://example.com/callback',
          logoutRedirectUri: 'https://example.com/logout',
          grantType: 'authorization_code',
        });
        const next = sinon.spy();
        sandbox.stub(KindeManagementApi.AuthorizationCode.prototype, 'generateAuthorizationURL').returns('https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&org_code=org_code&start_page=login');
        const req = {
          query: {
            state: 'random_state',
            org_code: 'org_code',
          },
          session: {},
        };
        const res = {
          redirect: sinon.stub(),
        };

        await kindeClient.login()(req, res, next);

        expect(res.redirect.calledOnce).to.be(true);
        expect(res.redirect.getCall(0).args[0]).to.be(`https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&org_code=org_code&start_page=login`);
        expect(req.session.kindeOauthState).to.be('random_state');
      });

      it('should call login throw an error', async () => {
        const next = sinon.spy();
        await instance.login()({}, {}, next);
        expect(next.calledOnce).to.be(true);
        expect(next.firstCall.args[0]).to.be.an(Error);
      });

    });

    describe('register', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call register successfully', async () => {
        const kindeClient = new KindeManagementApi.KindeClient({
          domain: 'https://example.com',
          clientId: 'client_id',
          clientSecret: 'client_secret',
          redirectUri: 'https://example.com/callback',
          logoutRedirectUri: 'https://example.com/logout',
          grantType: 'authorization_code',
        });
        const req = {
          query: {
            state: 'random_state',
            org_code: 'org_code',
          },
          session: {},
        };
        const res = {
          redirect: sinon.stub(),
        };
        const next = sinon.spy();
        sandbox.stub(KindeManagementApi.AuthorizationCode.prototype, 'generateAuthorizationURL').returns('https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&org_code=org_code&start_page=registration');
        await kindeClient.register()(req, res, next);
        expect(res.redirect.calledOnce).to.be(true);
        expect(res.redirect.getCall(0).args[0]).to.be(`https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&org_code=org_code&start_page=registration`);
        expect(req.session.kindeOauthState).to.be('random_state');
      });

      it('should call register throw an error', async () => {
        const next = sinon.spy();
        await instance.register()({}, {}, next);
        expect(next.calledOnce).to.be(true);
        expect(next.firstCall.args[0]).to.be.an(Error);
      });
    });

    describe('callback', function() {
      let client;
      let req;
      let res;
      let next;

      beforeEach(() => {
        const options = {
          domain: 'https://example.com',
          clientId: '12345',
          clientSecret: 'secret',
          redirectUri: 'https://example.com/callback',
          logoutRedirectUri: 'https://example.com/logout',
          grantType: 'authorization_code',
        };
        client = new KindeManagementApi.KindeClient(options);
        req = {
          session: {},
          query: {},
        };
        res = {};
        next = sinon.spy();
      });

      it('should call callback throws an error', async () => {
        await client.callback()(req, res, next);
        expect(next.calledOnce).to.be(true);
        expect(next.calledWithExactly(sinon.match.instanceOf(Error))).to.be(true);
      });

      it('should call callback successfully', async () => {
        const req = {
          session: {
            kindeOauthState: 'state',
          },
          query: {
            code: 'abc',
            state: 'state',
          }
        };
        const res = {};
        const next = sinon.spy();
        const getTokenStub = sinon.stub(KindeManagementApi.AuthorizationCode.prototype, 'getToken').resolves({});
        const saveTokenStub = sinon.stub(client, 'saveToken');
        await client.callback()(req, res, next);
        expect(next.calledOnce).to.be(true);
        expect(getTokenStub.calledOnce).to.be(true);
        expect(saveTokenStub.calledOnce).to.be(true);
        getTokenStub.restore();
        saveTokenStub.restore();
      });
    });

    describe('createOrg', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call createOrg successfully', async () => {
        const kindeClient = new KindeManagementApi.KindeClient({
          domain: 'https://example.com',
          clientId: 'client_id',
          clientSecret: 'client_secret',
          redirectUri: 'https://example.com/callback',
          logoutRedirectUri: 'https://example.com/logout',
          grantType: 'authorization_code',
        });
        const req = {
          query: {
            state: 'random_state',
            org_code: 'org_code',
          },
          session: {},
        };
        const res = {
          redirect: sinon.stub(),
        };
        const next = sinon.spy();
        sandbox.stub(KindeManagementApi.AuthorizationCode.prototype, 'generateAuthorizationURL').returns('https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&start_page=registration&is_create_org=true&org_name=org_name');
        await kindeClient.createOrg()(req, res, next);  
        expect(res.redirect.calledOnce).to.be(true);
        expect(res.redirect.getCall(0).args[0]).to.be(`https://example.com/oauth2/auth?response_type=code&client_id=client_id&redirect_uri=http%3A%2F%2Flocalhost%3A3000%2Fcallback&scope=openid%20profile%20email%20offline&state=random_state&start_page=registration&is_create_org=true&org_name=org_name`);
        expect(req.session.kindeOauthState).to.be('random_state');
      });

      it('should call createOrg throws an error', async () => {
        const next = sinon.spy();
        await instance.createOrg()({}, {}, next);
        expect(next.calledOnce).to.be(true);
        expect(next.firstCall.args[0]).to.be.an(Error);
      });
    });

    describe('logout', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });
      
      afterEach(() => {
        sandbox.restore();
      });

      it('should call logout successfully', () => {
        const req = {};
        const res = {
          redirect: sinon.spy(),
        };
        sandbox.stub(instance, 'cleanSession');
        instance.logout()(req, res);
        expect(res.redirect.calledWith('https://example.com/logout?redirect=https://example.com/logout')).to.be(true);
      });

      it('should call logout throws an error', () => {
        const req = {};
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.spy(),
        };
        const errorMessage = 'An error occurred while cleaning session';
        sandbox.stub(instance, 'cleanSession').throws(new Error(errorMessage));
        instance.logout()(req, res);
        expect(res.status.calledWith(500)).to.be(true);
        expect(res.json.calledWith({ error: errorMessage })).to.be(true);
      });
    });

    describe('getToken', () => {
      let sandbox;
    
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });
    
      afterEach(() => {
        sandbox.restore();
      });
       
      it('should call getToken successfully', async () => {
        const request = {
          session: {
            kindeAccessToken: 'my.access-token.example',
            kindeRefreshToken: 'my.refresh-token.example',
            kindeLoginTimeStamp: Date.now() / 1000,
            kindeExpiresIn: 3600,
          },
        };
    
        sandbox.stub(instance, 'isTokenExpired').returns(false);     
        const result = await instance.getToken(request);
        expect(result).to.be('my.access-token.example');
      });    
    });

    describe('saveToken', () => {
      let request = null;
      const payloadAccessToken = {
        aud: [],
        azp: '09b4aec1c8b14c11a83ed94d458d605f',
        exp: Date.now(),
        feature_flags: {
          competitions_limit: { t: 'i', v: 5 },
          is_dark_mode: { t: 'b', v: true },
          pink: { t: 's', v: 'pink' },
          test: { t: 'b', v: false },
          test1: { t: 'i', v: 5 },
          theme: { t: 's', v: 'pink1' }
        },
        iat: 1681978619,
        iss: 'https://nguyenstsdev-dev.au.kinde.com',
        jti: '2accb1dc-b9da-4f63-8b0f-a3dfae721f40',
        org_code: 'org_7052552de68',
        permissions: [ 'update:todos', 'create:todos' ],
        scp: [ 'openid', 'profile', 'email', 'offline' ],
        sub: 'kp:0094bbe7230c42f3be027b52e4e179a5'
      }; 
      const base64Payload = Buffer.from(JSON.stringify(payloadAccessToken)).toString('base64');
      const validToken = `header.${base64Payload}.signature`;
      const token = {
        access_token: validToken,
        id_token: validToken,
        expires_in: 3600,
        refresh_token: 'my.refresh-token.example',
      };
    
      beforeEach(() => {
        request = {
          session: {},
        };
      });
    
      it('should call saveToken successfully', () => {
        instance.saveToken(request, token);
    
        expect(request.session.kindeLoginTimeStamp).to.be.a('number');
        expect(request.session.kindeAccessToken).to.be.equal(validToken);
        expect(request.session.kindeIdToken).to.be.equal(validToken);
        expect(request.session.kindeExpiresIn).to.be.equal(3600);
        expect(request.session.kindeRefreshToken).to.be.equal('my.refresh-token.example');
      });
    });

    describe('isTokenExpired', () => {
      it('should call isTokenExpired return true if it is expired', () => {
        const request = {
          session: {
            kindeLoginTimeStamp: Date.now() - 3601*1000,
            kindeExpiresIn: 3600 // 1 hour
          }
        };
        const result = instance.isTokenExpired(request);
        expect(result).to.be(true);
      });
  
      it('should call isTokenExpired return false if it is not expired', () => {
        const request = {
          session: {
            kindeLoginTimeStamp: Date.now() - 1000,
            kindeExpiresIn: 3600 // 1 hour
          }
        };
        const result = instance.isTokenExpired(request);
        expect(result).to.be(false);
      });
    });

    describe('getFlag', () => {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getFlag return the flag value if it is found', () => {
        const request = {
          session: {
            kindeFeatureFlags: {
              'my-flag': { t: 'i', v: 123 }
            }
          }
        };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getFlag(request, 'my-flag');
        expect(result.code).to.equal('my-flag');
        expect(result.type).to.equal('integer');
        expect(result.value).to.equal(123);
        expect(result.is_default).to.equal(false);
      });

      it('should call getFlag return the default value if the flag is not found', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        const defaultValue = true;
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getFlag(request, 'my-flag', { defaultValue }, 'b');
        expect(result.code).to.equal('my-flag');
        expect(result.type).to.equal('boolean');
        expect(result.value).to.equal(true);
        expect(result.is_default).to.equal(true);
      });
  
      it('should call getFlag throw error if the flag is not found and no default provided', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getFlag(request, 'my-flag');
        }).to.throwError('Flag my-flag does not exist, and no default value has been provided');
      });

      it('should call getFlag throw error if the flag is of type not boolean', () => {
        const request = { session: { kindeFeatureFlags: {
          'my-flag': { t: 's', v: 'a' }
        } } };
        const defaultValue = 123;
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getFlag(request, 'my-flag', { defaultValue }, 'i');
        }).to.throwError('Flag my-flag is of type string - requested type integer');
      });

    });

    describe('getBooleanFlag', () => {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getBooleanFlag return the flag value if it is found', () => {
        const request = {
          session: {
            kindeFeatureFlags: {
              'my-flag': { t: 'b', v: false }
            }
          }
        };
        const defaultValue = true;
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getBooleanFlag(request, 'my-flag', defaultValue);
        expect(result).to.be(false);
      });

      it('should call getBooleanFlag return the default value if the flag is not found', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        const defaultValue = true;
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getBooleanFlag(request, 'my-flag', defaultValue);
        expect(result).to.be(defaultValue);
      });
  
      it('should call getBooleanFlag throw error if the flag is not found and no default provided', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getBooleanFlag(request, 'my-flag');
        }).to.throwError('Flag my-flag does not exist, and no default value has been provided');
      });

      it('should call getBooleanFlag throw error if the flag is of type not boolean', () => {
        const request = { session: { kindeFeatureFlags: {
          'my-flag': { t: 's', v: 'a' }
        } } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getBooleanFlag(request, 'my-flag', false);
        }).to.throwError('Flag my-flag is of type string - requested type boolean');
      });

    });
  
    describe('getStringFlag', () => {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getStringFlag return the flag value if it is found', () => {
        const request = {
          session: {
            kindeFeatureFlags: {
              'my-flag': { t: 's', v: 'flag-value' }
            }
          }
        };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getStringFlag(request, 'my-flag');
        expect(result).to.be('flag-value');
      });
  
      it('should call getStringFlag return the default value if the flag is not found', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        const defaultValue = 'default-value';
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getStringFlag(request, 'my-flag', defaultValue);
        expect(result).to.be(defaultValue);
      });

      it('should call getStringFlag throw error if the flag is not found and no default provided', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getStringFlag(request, 'my-flag');
        }).to.throwError('Flag my-flag does not exist, and no default value has been provided');
      });

      it('should call getStringFlag throw error if the flag is of type not boolean', () => {
        const request = { session: { kindeFeatureFlags: {
          'my-flag': { t: 'b', v: true }
        } } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getStringFlag(request, 'my-flag', false);
        }).to.throwError('Flag my-flag is of type string - requested type boolean');
      });
    });
  
    describe('getIntegerFlag', () => {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getIntegerFlag return the flag value if it is found', () => {
        const request = {
          session: {
            kindeFeatureFlags: {
              'my-flag': { t: 'i', v: 123 }
            }
          }
        };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getIntegerFlag(request, 'my-flag');
        expect(result).to.be(123);
      });

      it('should call getIntegerFlag return the default value if the flag is not found', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        const defaultValue = 42;
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        const result = instance.getIntegerFlag(request, 'my-flag', defaultValue);
        expect(result).to.be(defaultValue);
      });

      it('should call getIntegerFlag throw error if the flag is not found and no default provided', () => {
        const request = { session: { kindeFeatureFlags: {} } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getIntegerFlag(request, 'my-flag');
        }).to.throwError('Flag my-flag does not exist, and no default value has been provided');
      });

      it('should call getIntegerFlag throw error if the flag is of type not boolean', () => {
        const request = { session: { kindeFeatureFlags: {
          'my-flag': { t: 'b', v: true }
        } } };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        expect(() => {
          instance.getIntegerFlag(request, 'my-flag', false);
        }).to.throwError('Flag my-flag is of type integer - requested type boolean');
      });
    });

    describe('cleanSession', function() {
      it('should call cleanSession successfully', function() {
        const request = { session: { destroy: sinon.stub() } };
        instance.cleanSession(request);
        expect(request.session.destroy.calledOnce).to.be.true;
      });
    });

    describe('isAuthenticated', function() {
      it('should call isAuthenticated return true', () => {
        const request = {
          session: {
            kindeLoginTimeStamp: Date.now(),
            kindeExpiresIn: 10,
          }
        };
        const isAuthenticated = instance.isAuthenticated(request);
        expect(isAuthenticated).to.be(true);
      });

      it('should call isAuthenticated return false', () => {
        const request = {
          session: {}
        };
        const isAuthenticated = instance.isAuthenticated(request);
        expect(isAuthenticated).to.be(false);
      });
    });

    describe('getUserDetails', function() {
      it('should call getUserDetails successfully', function() {
        const request = {
          session: {
            kindeLoginTimeStamp: Date.now() / 1000,
            kindeExpiresIn: 3600,
            kindeUser: {
              name: 'John Doe',
              email: 'johndoe@example.com',
            }
          }
        };
        const isAuthenticatedStub = sinon.stub(instance, 'isAuthenticated').returns(true);  
        const userDetails = instance.getUserDetails(request);  
        expect(userDetails).to.eql({
          name: 'John Doe',
          email: 'johndoe@example.com',
        });
        isAuthenticatedStub.restore();
      });

      it('should call getUserDetails throw an error', function() {
        const request = {
          session: {}
        };
        const isAuthenticatedStub = sinon.stub(instance, 'isAuthenticated').returns(false);  
        expect(function() {
          instance.getUserDetails(request);
        }).to.throwError('Request is missing required authentication credential');
        isAuthenticatedStub.restore();
      });
    });

    describe('getClaims', function() {
      let request;
      let token;

      beforeEach(() => {
        request = {
          session: {},
        };
        token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
      });

      it('should call getClaims successfully', () => {
        request.session.kindeIdToken = token;
        const claims = instance.getClaims(request, 'id_token');
        expect(claims).to.be.an('object');
        expect(claims.sub).to.equal('1234567890');
        expect(claims.name).to.equal('John Doe');
        expect(claims.iat).to.equal(1516239022);
      });

      it('should call getClaims throw an error', () => {
        const fn = () => instance.getClaims(request, 'id_token');
        expect(fn).to.throwError('Request is missing required authentication credential');
      });
    });

    describe('getClaim', function() {
      let sandbox;
      const request = {
        session: {
          kindeAccessToken: 'fakeAccessToken',
          kindeIdToken: 'fakeIdToken',
        }
      };

      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getClaim successfully', () => {
        const fakeTokenData = {
          sub: '12345',
          email: 'johndoe@example.com',
        };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        sandbox.stub(instance, 'getClaims').returns(fakeTokenData);
        const claimValue = instance.getClaim(request, 'email', 'access_token');
        expect(claimValue.name).to.equal('email');
        expect(claimValue.value).to.equal('johndoe@example.com');
      });

      it('should call getClaim throw an error', () => {
        sandbox.stub(instance, 'isAuthenticated').returns(false);
        expect(() => {
          instance.getClaim(request, 'email', 'access_token');
        }).to.throwError('Request is missing required authentication credential');
      });
    });

    describe('getPermissions', function() {
      it('should call getPermissions throw an error', () => {
        const request = {
          session: {},
        };
        expect(() => instance.getPermissions(request)).to.throwException((exception) => {
          expect(exception.message).to.be('Request is missing required authentication credential');
        });
      });

      it('should call getPermissions successfully', () => { 
        const orgCode = 'org123';
        const permissions = ['view', 'edit'];
        const claims = {
          org_code: orgCode,
          permissions: permissions,
        };
        const sandbox = sinon.createSandbox();
        sandbox.stub(KindeManagementApi.KindeClient.prototype, 'isAuthenticated').returns(true);
        sandbox.stub(KindeManagementApi.KindeClient.prototype, 'getClaims').returns(claims);  
        const request = {
          session: {
            kindeAccessToken: 'access-token',
          },
        };
        const expectedPermissions = {
          orgCode: orgCode,
          permissions: permissions,
        };
        expect(instance.getPermissions(request)).to.eql(expectedPermissions);
        sandbox.restore();
      });
    });

    describe('getPermission', function() {
      let sandbox;
      const sampleRequest = {
        session: {
          kindeAccessToken: 'Bearer sampleToken'
        }
      };
      const sampleClaims = {
        org_code: 'sampleOrgCode',
        permissions: ['permission1', 'permission2'],
      };

      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getPermission successfully', () => {
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        sandbox.stub(instance, 'getClaims').returns(sampleClaims);
        const result = instance.getPermission(sampleRequest, 'permission1');
        expect(result).to.be.an('object');
        expect(result.orgCode).to.eql('sampleOrgCode');
        expect(result.isGranted).to.be(true);
      });

      it('should call getPermission throw an error', () => {
        sandbox.stub(instance, 'isAuthenticated').returns(false);
        expect(() => {
          instance.getPermission(sampleRequest, 'permission1');
        }).to.throwError('Request is missing required authentication credential');
      });
    });

    describe('getOrganization', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });

      afterEach(() => {
        sandbox.restore();
      });

      it('should call getOrganization successfully ', () => {
        const request = {};
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        sandbox.stub(instance, 'getClaims').withArgs(request).returns({
          org_code: 'org-123'
        });    
        const result = instance.getOrganization(request);
        expect(result).to.eql({ orgCode: 'org-123' });
      });

      it('should call getOrganization throw an error', () => {
        const request = {};
        sandbox.stub(KindeManagementApi.KindeClient.prototype,'isAuthenticated').returns(false);  
        expect(() => instance.getOrganization(request)).to.throwError('Request is missing required authentication credential');
      });
    });

    describe('getUserOrganizations', function() {
      let sandbox;
      beforeEach(() => {
        sandbox = sinon.createSandbox();
      });
      
      afterEach(() => {
        sandbox.restore();
      });

      it('should call getUserOrganizations successfully', function() {
        const request = { session: { kindeIdToken: '123'} };
        sandbox.stub(instance, 'isAuthenticated').returns(true);
        sandbox.stub(instance, 'getClaims').withArgs(request, 'id_token').returns({
          org_codes: ['org1', 'org2']
        });
        const result = instance.getUserOrganizations(request);  
        expect(result).to.eql({ 
          orgCodes: ['org1', 'org2'] 
        });
      });
  
      it('should call getUserOrganizations throw an error', function() { 
        sandbox.stub(instance, 'isAuthenticated').returns(false);  
        const request = { session: { kindeIdToken: '123' } };  
        expect(() => instance.getUserOrganizations(request)).to.throwError('Request is missing required authentication credential');
      });
    });
  });
}));
